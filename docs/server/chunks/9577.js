"use strict";exports.id=9577,exports.ids=[9577],exports.modules={91958:(e,s,a)=>{a.r(s),a.d(s,{default:()=>i});var t=a(45512),n=a(64179),l=a(10721),r=a(32884),d=a(58009),o=a(42784),u=a(19312);let c=(0,o.c)("PrivyStrategy"),i=(0,d.memo)(({children:e,glyphUrl:s,onLogin:a,onLogout:i,useStagingTenant:g})=>{let[p,y]=(0,d.useState)(!0),[h,m]=(0,d.useState)(null),[f,b]=(0,d.useState)(null),[w,v]=(0,d.useState)(!1),k=(0,u.i)(),{ready:S,authenticated:T,user:G,getAccessToken:_,login:x,logout:A,signMessage:C,sendTransaction:E}=(0,n.u)(),{signMessage:M,sendTransaction:P}=(0,l.ae)();c.debug(S,T,!!G);let{wallets:W}=(0,r.u)();(0,d.useEffect)(()=>{let e;if(!S){m(null),y(!0);return}if(!T||!G){m(null),y(!1);return}let a=G.linkedAccounts?.find(e=>"wallet"===e.type&&"ethereum"===e.chainType&&"privy"===e.walletClientType),t=a&&(0,o.i)(a.address);t&&c.debug("Privy (main) EVM embedded wallet",a.address),c.debug("finding cross-app accounts...");let n=G.linkedAccounts?.filter?.(e=>"cross_app"===e.type)||[],l=n.filter(e=>e.providerApp?.id!==(g?o.S:o.G));c.debug("linked accounts - non-Glyph",{accounts:l});let r=l.map(e=>e.embeddedWallets[0].address);r.length>0&&(e=r[0],c.log("using cross_app (non-Glyph) account"),r.length>1&&c.warn("too many cross_app accounts"));let d=n.filter(e=>e.providerApp?.id===(g?o.S:o.G));c.debug("linked accounts - Glyph",{accounts:d});let u=d.map(e=>e.embeddedWallets[0].address);u.length>0&&(e=u[0],c.log("using cross_app (Glyph) account"),u.length>1&&c.warn("too many cross_app accounts")),e?(v(!0),c.log("using cross_app account",e)):t&&(e=a.address,c.log("using Privy (main) EVM embedded wallet",e)),b(e??null),(async()=>{if(!e){c.error("user has no wallet");return}let a=(0,o.b)(s||o.W,async()=>await _(),{"x-evm-address":e});m(()=>a),y(!1)})()},[s,T,S,G,g,w,W,f,_,A]);let L=(0,d.useCallback)(async()=>{await x(),a?.()},[a,x]),N=(0,d.useCallback)(async()=>{A(),i?.()},[i,A]),U=(0,d.useCallback)(async({message:e})=>{if(!f)throw Error("No wallet address found");return w?M(e,{address:f}):C({message:e})},[f,w,M,C]),V=(0,d.useCallback)(async({transaction:e})=>{if(!f)throw Error("No wallet address found");let s={...e,chainId:k};return w?P(s,{address:f}):E(s,{address:f})},[k,w,f,P,E]);return(0,t.jsx)(o.a.Provider,{value:{ready:S&&!p,authenticated:S&&T,glyphUrl:s,login:L,logout:N,signMessage:U,sendTransaction:V,apiFetch:h},children:e})})}};