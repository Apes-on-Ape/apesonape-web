"use strict";exports.id=216,exports.ids=[216],exports.modules={80216:(e,t,a)=>{a.r(t),a.d(t,{AwaitingExternalEthereumTransferScreen:()=>M,default:()=>M});var n=a(45512),i=a(90788),s=a(58009),r=a(98001),d=a(7538),o=a(84126),c=a(53942),l=a(97922),u=a(445),h=a(86388),g=a(20056),f=a(45549),m=a(65500),p=a(18064),v=a(75005),y=a(7666),C=a(98434),b=a(8601),T=a(76284),I=a(66658),w=a(37782),S=a(59677),E=a(32884),x=a(6174),A=a(80589),N=a(14565),F=a(52760),B=a(87237),j=a(10721),U=a(46445),$=a(54732),k=a(91746),D=a(71468);a(5327),a(7623),a(61889),a(25998),a(88527);let M={component:()=>{let{rpcConfig:e,appId:t,closePrivyModal:a,createAnalyticsEvent:M}=(0,T.u)(),{navigate:H,setModalData:P,data:q}=(0,w.a)(),L=(0,b.u)(),{wallets:W}=(0,E.u)(),[_,Q]=(0,s.useState)(!1),[R,J]=(0,s.useState)(0n),[O,V]=(0,s.useState)(!1),[Y,z]=(0,s.useState)(null),[G,K]=(0,s.useState)(null),[X,Z]=(0,s.useState)([]),[ee,et]=(0,s.useState)(0),[ea,en]=(0,s.useState)(!1),[ei,es]=(0,s.useState)(!1),[er,ed]=(0,s.useState)(!1),[eo,ec]=(0,s.useState)(!1),[el,eu]=(0,s.useState)(),[eh,eg]=(0,s.useState)();if(!q?.funding||"ethereum"!==q.funding.chainType)throw Error("Invalid funding data");let{erc20ContractInfo:ef,chain:em,connectedWallet:ep}=q.funding,ev=q.funding.address,ey=q.funding.erc20Address,[eC,eb]=(0,s.useState)(q.funding.amount);(0,s.useEffect)(()=>{ey&&!ef&&z(Error("Unable to fetch token details"))},[]);let eT=!!ey&&!!ef,eI=eT?BigInt(parseFloat(eC)*10**ef.decimals):(0,r.g)(eC),ew=("ethereum"===ep?.type?ep:void 0)??W[0],eS=(0,I.Q)(ew?.walletClientType||"unknown"),eE=eS?.name||"wallet",[ex,eA]=(0,s.useState)(null);(0,s.useEffect)(()=>{(async()=>{if(!ew)return;let e=await ew.getEthereumProvider();eA((0,d.F)({account:ew.address,transport:(0,o.I)(e)}).extend(c.$))})().catch(console.error)},[ew]);let[eN,eF]=(0,s.useState)(0n);(0,s.useEffect)(()=>{(0,l.l)({chain:em,transport:(0,u.L)((0,k.a)(em,e,t))}).getBalance({address:ev}).then(eF).catch(console.error)},[]);let[eB,ej]=(0,s.useState)(0n);(0,s.useEffect)(()=>{eT&&(0,$.g)({chain:em,address:ev,appId:t,rpcConfig:e,erc20Address:ey}).then(e=>ej(e.balance)).catch(console.error)},[]);let{tokenPrice:eU}=(0,S.u)(em.id),[e$,ek]=(0,s.useState)({to:ev,chain:em,value:eI,data:void 0});(0,s.useEffect)(()=>{(async()=>{let a,n;if(!ex||!ew||ea||er)return;en(!0);let i=(0,l.l)({chain:e$.chain,transport:(0,u.L)((0,k.a)(e$.chain,e,t))});if(eT&&!e$.data)return await i.simulateContract({address:ey,chain:e$.chain,abi:x.E,functionName:"transfer",args:[ev,eI],account:ew.address}).catch(e=>{console.warn("Simulated token transfer failed with error, fetching bridge options.",e)})?(en(!1),void ek({to:ey,chain:e$.chain,data:(0,h.p)({abi:x.E,functionName:"transfer",args:[ev,eI]}),value:"0x0"})):(en(!1),void V(!0));try{a=await i.prepareTransactionRequest({account:ew.address,to:e$.to,chain:e$.chain,data:e$.data,value:BigInt(e$.value??0)})}catch(e){if(console.error(e),X.length>1)K(e.shortMessage??"Something went wrong");else if(ei&&0===X.length)return void z(new T.a(`Wallet ${(0,I.D)(ew.address)} does not have enough funds.`,void 0,T.b.INSUFFICIENT_BALANCE))}if(!a)return en(!1),void V(!0);en(!1),ed(!0),Q(!0),J(a.gas);try{await ex.switchChain({id:e$.chain.id})}catch(e){await ex.addChain({chain:e$.chain}),await ex.switchChain({id:e$.chain.id})}try{n=await ex.sendTransaction(a)}catch(e){if(console.error(e),"TransactionExecutionError"===e.name){if(X.length<1){let t=e.shortMessage;(e.shortMessage.includes("rejected the request")||e.details.includes("rejected the request"))&&(t="User rejected the request."),z(new T.a(t,void 0,T.b.TRANSACTION_FAILURE))}else K(e.shortMessage??"Something went wrong")}}if(n)return await ex.waitForTransactionReceipt({hash:n}),ed(!1),ei?(eu(n),void eg("pending")):(ec(!0),P((0,j.A)(q,"completed",n,ew?.walletClientType,eT,ef,em)),void M({eventName:F.O,payload:{provider:"external",status:"success",txHash:n,address:ew.address,chainId:e$.chain.id,chainType:"ethereum",value:e$.value?(0,g.J)(BigInt(e$.value),ef?.decimals??18):void 0,token:ef?.symbol??ey??"ETH",destinationAddress:ev,destinationChainId:em.id,destinationChainType:"ethereum",destinationValue:eI?(0,g.J)(eI,ef?.decimals??18):void 0,destinationToken:ef?.symbol??ey??em.nativeCurrency.name}}));ed(!1)})().catch(console.error)},[ex,e$]),(0,s.useEffect)(()=>{(async()=>{if(!O||!ex||!ew)return;let a=(0,f.u)(L.chains).filter(e=>e.id!==em.id&&!!e.testnet==!!em.testnet);eT&&a.unshift(em);let n=await (0,U.g)({chains:a,address:ew.address,appId:t,rpcConfig:e,includeUsdc:q.funding?.isUSDC}),i=eT?n.filter(e=>e.balance>0n):n.filter(e=>e.balance>eI),s=eT&&n.every(e=>0n===e.balance);if(i.length<1)return void z(new T.a(s?`Wallet ${(0,I.D)(ew.address)} doesn't have enough funds to cover gas fees. Top up your wallet and try again.`:`Wallet ${(0,I.D)(ew.address)} does not have enough funds.`,void 0,T.b.INSUFFICIENT_BALANCE));i.sort((e,t)=>Number(eT?(t.erc20Balance??0n)-(e.erc20Balance??0n):t.balance-e.balance));let r=i.flatMap(e=>{let a=[{...e,isErc20Quote:!1,isTestnet:!!em.testnet,input:(0,B.t)({appId:t,amount:eI.toString(),user:ew.address,recipient:ev,destinationChainId:em.id,destinationCurrency:ey,originChainId:e.chain.id})}];return eT&&ey&&(e.erc20Balance??0n)>=eI&&a.push({...e,isErc20Quote:!0,isTestnet:!!em.testnet,input:(0,B.t)({appId:t,amount:eI.toString(),user:ew.address,recipient:ev,destinationChainId:em.id,destinationCurrency:ey,originChainId:e.chain.id,originCurrency:e.erc20Address})}),a}),d=(await Promise.allSettled(r.map(async e=>({...e,quote:await (0,B.g)(e)})))).filter(e=>"fulfilled"===e.status).map(e=>e.value);if(d.length<1)return void z(new T.a(`Wallet ${(0,I.D)(ew.address)} does not have enough funds.`,void 0,T.b.INSUFFICIENT_BALANCE));let o=d.map(e=>({bridgeTx:(0,B.c)(e.quote),balance:e.balance,chain:e.chain,erc20Balance:e.erc20Balance,isErc20Quote:e.isErc20Quote})).filter(e=>!!e.bridgeTx);if(o.length>1)return void Z(o);let c=o[0];c?(es(!0),ek({data:c.bridgeTx.data,to:c.bridgeTx.to,value:c.bridgeTx.value,chain:c.chain})):z(new T.a(`Wallet ${(0,I.D)(ew.address)} does not have enough funds.`,void 0,T.b.INSUFFICIENT_BALANCE))})().catch(console.error)},[O]),(0,B.u)({transactionHash:el,isTestnet:!!em.testnet,bridgingStatus:eh,setBridgingStatus:eg,onSuccess({transactionHash:e}){es(!1),ec(!0),P((0,j.A)(q,"completed",e,ew?.walletClientType,eT,ef,em)),M({eventName:F.O,payload:{provider:"external",status:"success",txHash:e,address:ew?.address,chainId:e$.chain.id,chainType:"ethereum",value:e$.value?(0,g.J)(BigInt(e$.value),ef?.decimals??18):void 0,token:ef?.symbol??ey??"ETH",destinationAddress:ev,destinationChainId:em.id,destinationChainType:"ethereum",destinationValue:eI?(0,g.J)(eI,ef?.decimals??18):void 0,destinationToken:ef?.symbol??ey??em.nativeCurrency.name}})},onFailure({error:e}){es(!1),z(e)}}),(0,s.useEffect)(()=>{Y&&(P({funding:q?.funding,solanaFundingData:q?.solanaFundingData,sendTransaction:q?.sendTransaction,errorModalData:{error:Y,previousScreen:"TransferFromWalletScreen"}}),H("ErrorScreen",!1))},[Y]);let eD=!eT&&eU?(0,N.c)(eC??"0",eU):void 0,eM=eT?R:(0,N.s)([R,eI]),eH=eM&&eU?(0,N.a)(eM,eU):void 0,eP=eM?(0,N.g)(eM,q?.funding?.erc20Address?q?.funding?.erc20ContractInfo?.symbol||"ETH":q?.funding?.chain.nativeCurrency.symbol||"ETH"):void 0,eq=R&&eU?(0,N.a)(R,eU):void 0,eL=R?(0,N.g)(R,em?.nativeCurrency?.symbol||"ETH"):void 0;if((0,s.useEffect)(()=>{if(!eo)return;let e=setTimeout(a,b.t);return()=>clearTimeout(e)},[eo]),eo)return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(y.t,{}),(0,n.jsx)(m.b,{}),(0,n.jsxs)(m.c,{children:[(0,n.jsx)(i.A,{color:"var(--privy-color-success)",width:"64px",height:"64px"}),(0,n.jsx)(v.C,{title:"Success!",description:`Youâ€™ve successfully added ${eC} ${eT?ef.symbol:em.nativeCurrency.symbol} to your ${L.name} wallet. It may take a minute before the funds are available to use.`})]}),(0,n.jsx)(m.R,{}),(0,n.jsx)(p.B,{})]});let eW=eT?`${(0,A.f)({amount:eB,decimals:ef.decimals})}  ${ef.symbol}`:(0,N.g)(eN,em.nativeCurrency.symbol,3,!0),e_=X[ee];return X.length>1&&e_?(0,n.jsx)(U.B,{displayName:eE,configuredFundingChain:em,erc20ContractInfo:ef,formattedBalance:eW,fundingAmount:eC,fundingCurrency:eT?ef.symbol:em.nativeCurrency.symbol,fundingAmountInUsd:eD,options:X,selectedOption:e_,isPreparing:ea,isSubmitting:er,addressToFund:ev,fundingWalletAddress:ew?.address||"",errorMessage:G,onSubmit:()=>{q.funding?.amount!==eC?(async function(){if(ew&&e_)try{let e=await (0,B.g)({isTestnet:!!em.testnet,input:(0,B.t)({appId:t,amount:eI.toString(),user:ew.address,recipient:ev,destinationChainId:em.id,destinationCurrency:ey,originChainId:e_.chain.id})}),a=(0,B.c)(e);if(!a)throw Error("Invalid transaction request");es(!0),ek({data:a.data,to:a.to,value:a.value,chain:e_.chain})}catch(e){console.error(e),z(new T.a("Unable to fetch quotes for bridging",e,T.b.INSUFFICIENT_BALANCE))}})().catch(console.error):ek({to:e_.bridgeTx.to,data:e_.bridgeTx.data,value:e_.bridgeTx.value,chain:e_.chain})},onSelect:e=>{e!==ee&&(K(null),et(e))},onAmountChange:eb}):_&&R&&ew&&q?.funding?(0,n.jsx)(D.T,{walletClientType:ew?.walletClientType||"unknown",displayName:eE,addressToFund:ev,isBridging:ei,isErc20Flow:eT,totalPriceInUsd:eH,totalPriceInNativeCurrency:eP,gasPriceInUsd:eq,gasPriceInNativeCurrency:eL,chainId:em.id,chainName:em.name}):(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(y.t,{}),(0,n.jsx)(C.N,{}),(0,n.jsx)("div",{style:{marginTop:"1rem"}}),(0,n.jsx)(p.B,{})]})}}},6174:(e,t,a)=>{a.d(t,{E:()=>n});let n=[{constant:!1,inputs:[{name:"_to",type:"address"},{name:"_value",type:"uint256"}],name:"transfer",outputs:[{name:"",type:"bool"}],payable:!1,stateMutability:"nonpayable",type:"function"}]}};