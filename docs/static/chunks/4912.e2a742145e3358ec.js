"use strict";(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[4912],{14912:(e,t,a)=>{a.r(t),a.d(t,{AwaitingExternalEthereumTransferScreen:()=>D,default:()=>D});var n=a(95155),i=a(14826),s=a(12115),r=a(37455),d=a(94895),o=a(77271),c=a(80205),l=a(11326),u=a(96355),h=a(74046),g=a(89888),f=a(46655),m=a(59242),p=a(40639),v=a(86777),y=a(25202),C=a(78584),b=a(81084),T=a(31679),I=a(48568),w=a(5944),E=a(45409),S=a(38856),x=a(79450),N=a(19129),A=a(72173),F=a(67526),B=a(73899),j=a(24511),k=a(21984),U=a(64506),_=a(45244),$=a(65310);a(68943),a(47147),a(29761),a(89208),a(85243);let D={component:()=>{let{rpcConfig:e,appId:t,closePrivyModal:a,createAnalyticsEvent:D}=(0,T.u)(),{navigate:M,setModalData:H,data:P}=(0,w.a)(),q=(0,b.u)(),{wallets:L}=(0,S.u)(),[W,Q]=(0,s.useState)(!1),[R,J]=(0,s.useState)(0n),[O,V]=(0,s.useState)(!1),[Y,z]=(0,s.useState)(null),[G,K]=(0,s.useState)(null),[X,Z]=(0,s.useState)([]),[ee,et]=(0,s.useState)(0),[ea,en]=(0,s.useState)(!1),[ei,es]=(0,s.useState)(!1),[er,ed]=(0,s.useState)(!1),[eo,ec]=(0,s.useState)(!1),[el,eu]=(0,s.useState)(),[eh,eg]=(0,s.useState)();if(!P?.funding||"ethereum"!==P.funding.chainType)throw Error("Invalid funding data");let{erc20ContractInfo:ef,chain:em,connectedWallet:ep}=P.funding,ev=P.funding.address,ey=P.funding.erc20Address,[eC,eb]=(0,s.useState)(P.funding.amount);(0,s.useEffect)(()=>{ey&&!ef&&z(Error("Unable to fetch token details"))},[]);let eT=!!ey&&!!ef,eI=eT?BigInt(parseFloat(eC)*10**ef.decimals):(0,r.g)(eC),ew=("ethereum"===ep?.type?ep:void 0)??L[0],eE=(0,I.Q)(ew?.walletClientType||"unknown"),eS=eE?.name||"wallet",[ex,eN]=(0,s.useState)(null);(0,s.useEffect)(()=>{(async()=>{if(!ew)return;let e=await ew.getEthereumProvider();eN((0,d.F)({account:ew.address,transport:(0,o.I)(e)}).extend(c.$))})().catch(console.error)},[ew]);let[eA,eF]=(0,s.useState)(0n);(0,s.useEffect)(()=>{(0,l.l)({chain:em,transport:(0,u.L)((0,_.a)(em,e,t))}).getBalance({address:ev}).then(eF).catch(console.error)},[]);let[eB,ej]=(0,s.useState)(0n);(0,s.useEffect)(()=>{eT&&(0,U.g)({chain:em,address:ev,appId:t,rpcConfig:e,erc20Address:ey}).then(e=>ej(e.balance)).catch(console.error)},[]);let{tokenPrice:ek}=(0,E.u)(em.id),[eU,e_]=(0,s.useState)({to:ev,chain:em,value:eI,data:void 0});(0,s.useEffect)(()=>{(async()=>{let a,n;if(!ex||!ew||ea||er)return;en(!0);let i=(0,l.l)({chain:eU.chain,transport:(0,u.L)((0,_.a)(eU.chain,e,t))});if(eT&&!eU.data)return await i.simulateContract({address:ey,chain:eU.chain,abi:x.E,functionName:"transfer",args:[ev,eI],account:ew.address}).catch(e=>{console.warn("Simulated token transfer failed with error, fetching bridge options.",e)})?(en(!1),void e_({to:ey,chain:eU.chain,data:(0,h.p)({abi:x.E,functionName:"transfer",args:[ev,eI]}),value:"0x0"})):(en(!1),void V(!0));try{a=await i.prepareTransactionRequest({account:ew.address,to:eU.to,chain:eU.chain,data:eU.data,value:BigInt(eU.value??0)})}catch(e){if(console.error(e),X.length>1)K(e.shortMessage??"Something went wrong");else if(ei&&0===X.length)return void z(new T.a(`Wallet ${(0,I.D)(ew.address)} does not have enough funds.`,void 0,T.b.INSUFFICIENT_BALANCE))}if(!a)return en(!1),void V(!0);en(!1),ed(!0),Q(!0),J(a.gas);try{await ex.switchChain({id:eU.chain.id})}catch(e){await ex.addChain({chain:eU.chain}),await ex.switchChain({id:eU.chain.id})}try{n=await ex.sendTransaction(a)}catch(e){if(console.error(e),"TransactionExecutionError"===e.name){if(X.length<1){let t=e.shortMessage;(e.shortMessage.includes("rejected the request")||e.details.includes("rejected the request"))&&(t="User rejected the request."),z(new T.a(t,void 0,T.b.TRANSACTION_FAILURE))}else K(e.shortMessage??"Something went wrong")}}if(n)return await ex.waitForTransactionReceipt({hash:n}),ed(!1),ei?(eu(n),void eg("pending")):(ec(!0),H((0,j.A)(P,"completed",n,ew?.walletClientType,eT,ef,em)),void D({eventName:F.O,payload:{provider:"external",status:"success",txHash:n,address:ew.address,chainId:eU.chain.id,chainType:"ethereum",value:eU.value?(0,g.J)(BigInt(eU.value),ef?.decimals??18):void 0,token:ef?.symbol??ey??"ETH",destinationAddress:ev,destinationChainId:em.id,destinationChainType:"ethereum",destinationValue:eI?(0,g.J)(eI,ef?.decimals??18):void 0,destinationToken:ef?.symbol??ey??em.nativeCurrency.name}}));ed(!1)})().catch(console.error)},[ex,eU]),(0,s.useEffect)(()=>{(async()=>{if(!O||!ex||!ew)return;let a=(0,f.u)(q.chains).filter(e=>e.id!==em.id&&!!e.testnet==!!em.testnet);eT&&a.unshift(em);let n=await (0,k.g)({chains:a,address:ew.address,appId:t,rpcConfig:e,includeUsdc:P.funding?.isUSDC}),i=eT?n.filter(e=>e.balance>0n):n.filter(e=>e.balance>eI),s=eT&&n.every(e=>0n===e.balance);if(i.length<1)return void z(new T.a(s?`Wallet ${(0,I.D)(ew.address)} doesn't have enough funds to cover gas fees. Top up your wallet and try again.`:`Wallet ${(0,I.D)(ew.address)} does not have enough funds.`,void 0,T.b.INSUFFICIENT_BALANCE));i.sort((e,t)=>Number(eT?(t.erc20Balance??0n)-(e.erc20Balance??0n):t.balance-e.balance));let r=i.flatMap(e=>{let a=[{...e,isErc20Quote:!1,isTestnet:!!em.testnet,input:(0,B.t)({appId:t,amount:eI.toString(),user:ew.address,recipient:ev,destinationChainId:em.id,destinationCurrency:ey,originChainId:e.chain.id})}];return eT&&ey&&(e.erc20Balance??0n)>=eI&&a.push({...e,isErc20Quote:!0,isTestnet:!!em.testnet,input:(0,B.t)({appId:t,amount:eI.toString(),user:ew.address,recipient:ev,destinationChainId:em.id,destinationCurrency:ey,originChainId:e.chain.id,originCurrency:e.erc20Address})}),a}),d=(await Promise.allSettled(r.map(async e=>({...e,quote:await (0,B.g)(e)})))).filter(e=>"fulfilled"===e.status).map(e=>e.value);if(d.length<1)return void z(new T.a(`Wallet ${(0,I.D)(ew.address)} does not have enough funds.`,void 0,T.b.INSUFFICIENT_BALANCE));let o=d.map(e=>({bridgeTx:(0,B.c)(e.quote),balance:e.balance,chain:e.chain,erc20Balance:e.erc20Balance,isErc20Quote:e.isErc20Quote})).filter(e=>!!e.bridgeTx);if(o.length>1)return void Z(o);let c=o[0];c?(es(!0),e_({data:c.bridgeTx.data,to:c.bridgeTx.to,value:c.bridgeTx.value,chain:c.chain})):z(new T.a(`Wallet ${(0,I.D)(ew.address)} does not have enough funds.`,void 0,T.b.INSUFFICIENT_BALANCE))})().catch(console.error)},[O]),(0,B.u)({transactionHash:el,isTestnet:!!em.testnet,bridgingStatus:eh,setBridgingStatus:eg,onSuccess({transactionHash:e}){es(!1),ec(!0),H((0,j.A)(P,"completed",e,ew?.walletClientType,eT,ef,em)),D({eventName:F.O,payload:{provider:"external",status:"success",txHash:e,address:ew?.address,chainId:eU.chain.id,chainType:"ethereum",value:eU.value?(0,g.J)(BigInt(eU.value),ef?.decimals??18):void 0,token:ef?.symbol??ey??"ETH",destinationAddress:ev,destinationChainId:em.id,destinationChainType:"ethereum",destinationValue:eI?(0,g.J)(eI,ef?.decimals??18):void 0,destinationToken:ef?.symbol??ey??em.nativeCurrency.name}})},onFailure({error:e}){es(!1),z(e)}}),(0,s.useEffect)(()=>{Y&&(H({funding:P?.funding,solanaFundingData:P?.solanaFundingData,sendTransaction:P?.sendTransaction,errorModalData:{error:Y,previousScreen:"TransferFromWalletScreen"}}),M("ErrorScreen",!1))},[Y]);let e$=!eT&&ek?(0,A.c)(eC??"0",ek):void 0,eD=eT?R:(0,A.s)([R,eI]),eM=eD&&ek?(0,A.a)(eD,ek):void 0,eH=eD?(0,A.g)(eD,P?.funding?.erc20Address?P?.funding?.erc20ContractInfo?.symbol||"ETH":P?.funding?.chain.nativeCurrency.symbol||"ETH"):void 0,eP=R&&ek?(0,A.a)(R,ek):void 0,eq=R?(0,A.g)(R,em?.nativeCurrency?.symbol||"ETH"):void 0;if((0,s.useEffect)(()=>{if(!eo)return;let e=setTimeout(a,b.t);return()=>clearTimeout(e)},[eo]),eo)return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(y.t,{}),(0,n.jsx)(m.b,{}),(0,n.jsxs)(m.c,{children:[(0,n.jsx)(i.A,{color:"var(--privy-color-success)",width:"64px",height:"64px"}),(0,n.jsx)(v.C,{title:"Success!",description:`Youâ€™ve successfully added ${eC} ${eT?ef.symbol:em.nativeCurrency.symbol} to your ${q.name} wallet. It may take a minute before the funds are available to use.`})]}),(0,n.jsx)(m.R,{}),(0,n.jsx)(p.B,{})]});let eL=eT?`${(0,N.f)({amount:eB,decimals:ef.decimals})}  ${ef.symbol}`:(0,A.g)(eA,em.nativeCurrency.symbol,3,!0),eW=X[ee];return X.length>1&&eW?(0,n.jsx)(k.B,{displayName:eS,configuredFundingChain:em,erc20ContractInfo:ef,formattedBalance:eL,fundingAmount:eC,fundingCurrency:eT?ef.symbol:em.nativeCurrency.symbol,fundingAmountInUsd:e$,options:X,selectedOption:eW,isPreparing:ea,isSubmitting:er,addressToFund:ev,fundingWalletAddress:ew?.address||"",errorMessage:G,onSubmit:()=>{P.funding?.amount!==eC?(async function(){if(ew&&eW)try{let e=await (0,B.g)({isTestnet:!!em.testnet,input:(0,B.t)({appId:t,amount:eI.toString(),user:ew.address,recipient:ev,destinationChainId:em.id,destinationCurrency:ey,originChainId:eW.chain.id})}),a=(0,B.c)(e);if(!a)throw Error("Invalid transaction request");es(!0),e_({data:a.data,to:a.to,value:a.value,chain:eW.chain})}catch(e){console.error(e),z(new T.a("Unable to fetch quotes for bridging",e,T.b.INSUFFICIENT_BALANCE))}})().catch(console.error):e_({to:eW.bridgeTx.to,data:eW.bridgeTx.data,value:eW.bridgeTx.value,chain:eW.chain})},onSelect:e=>{e!==ee&&(K(null),et(e))},onAmountChange:eb}):W&&R&&ew&&P?.funding?(0,n.jsx)($.T,{walletClientType:ew?.walletClientType||"unknown",displayName:eS,addressToFund:ev,isBridging:ei,isErc20Flow:eT,totalPriceInUsd:eM,totalPriceInNativeCurrency:eH,gasPriceInUsd:eP,gasPriceInNativeCurrency:eq,chainId:em.id,chainName:em.name}):(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(y.t,{}),(0,n.jsx)(C.N,{}),(0,n.jsx)("div",{style:{marginTop:"1rem"}}),(0,n.jsx)(p.B,{})]})}}},79450:(e,t,a)=>{a.d(t,{E:()=>n});let n=[{constant:!1,inputs:[{name:"_to",type:"address"},{name:"_value",type:"uint256"}],name:"transfer",outputs:[{name:"",type:"bool"}],payable:!1,stateMutability:"nonpayable",type:"function"}]}}]);