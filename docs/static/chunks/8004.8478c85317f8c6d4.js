"use strict";(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[8004],{18004:(e,a,s)=>{s.r(a),s.d(a,{default:()=>i});var n=s(95155),t=s(45687),l=s(24511),r=s(38856),d=s(12115),u=s(21833),c=s(48517);let o=(0,u.c)("PrivyStrategy"),i=(0,d.memo)(({children:e,glyphUrl:a,onLogin:s,onLogout:i,useStagingTenant:g})=>{let[p,y]=(0,d.useState)(!0),[h,f]=(0,d.useState)(null),[b,m]=(0,d.useState)(null),[w,k]=(0,d.useState)(!1),v=(0,c.i)(),{ready:_,authenticated:S,user:C,getAccessToken:E,login:T,logout:G,signMessage:A,sendTransaction:M}=(0,t.u)(),{signMessage:N,sendTransaction:P}=(0,l.ae)();o.debug(_,S,!!C);let{wallets:W}=(0,r.u)();(0,d.useEffect)(()=>{let e;if(!_){f(null),y(!0);return}if(!S||!C){f(null),y(!1);return}let s=C.linkedAccounts?.find(e=>"wallet"===e.type&&"ethereum"===e.chainType&&"privy"===e.walletClientType),n=s&&(0,u.i)(s.address);n&&o.debug("Privy (main) EVM embedded wallet",s.address),o.debug("finding cross-app accounts...");let t=C.linkedAccounts?.filter?.(e=>"cross_app"===e.type)||[],l=t.filter(e=>e.providerApp?.id!==(g?u.S:u.G));o.debug("linked accounts - non-Glyph",{accounts:l});let r=l.map(e=>e.embeddedWallets[0].address);r.length>0&&(e=r[0],o.log("using cross_app (non-Glyph) account"),r.length>1&&o.warn("too many cross_app accounts"));let d=t.filter(e=>e.providerApp?.id===(g?u.S:u.G));o.debug("linked accounts - Glyph",{accounts:d});let c=d.map(e=>e.embeddedWallets[0].address);c.length>0&&(e=c[0],o.log("using cross_app (Glyph) account"),c.length>1&&o.warn("too many cross_app accounts")),e?(k(!0),o.log("using cross_app account",e)):n&&(e=s.address,o.log("using Privy (main) EVM embedded wallet",e)),m(e??null),(async()=>{if(!e){o.error("user has no wallet");return}let s=(0,u.b)(a||u.W,async()=>await E(),{"x-evm-address":e});f(()=>s),y(!1)})()},[a,S,_,C,g,w,W,b,E,G]);let x=(0,d.useCallback)(async()=>{await T(),s?.()},[s,T]),L=(0,d.useCallback)(async()=>{G(),i?.()},[i,G]),U=(0,d.useCallback)(async({message:e})=>{if(!b)throw Error("No wallet address found");return w?N(e,{address:b}):A({message:e})},[b,w,N,A]),V=(0,d.useCallback)(async({transaction:e})=>{if(!b)throw Error("No wallet address found");let a={...e,chainId:v};return w?P(a,{address:b}):M(a,{address:b})},[v,w,b,P,M]);return(0,n.jsx)(u.a.Provider,{value:{ready:_&&!p,authenticated:_&&S,glyphUrl:a,login:x,logout:L,signMessage:U,sendTransaction:V,apiFetch:h},children:e})})}}]);